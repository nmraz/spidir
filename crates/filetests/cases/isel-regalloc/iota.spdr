# run: isel-regalloc

func @iota(ptr, i64) {
    # check: function `iota`:
    # nextln: clobbers: rax, rcx, rdx, r8
    # nextln: frame: size 0, align 0
    # nextln:       block0:
    # nextln: 0000:     $$rax = MovRZ
    # nextln: 0001:     AluRRm(S64, Test) $$rsi, $$rsi
    # nextln: 0002:     Jumpcc(E, block1, block3)
    # nextln:       block1:
    # nextln: 0003:     Jump(block2)
    # nextln:       block3:
    # nextln: 0004:     $$rcx = MovRmS32(3)
    # nextln: 0005:     Jump(block4)
    # nextln:       block4:
    # nextln:           $$rdx = $$rax
    # nextln: 0006:     $$rdx = ShiftRmR(S64, Shl) $$rdx, $$rcx
    # nextln:           $$r8 = $$rdi
    # nextln: 0007:     $$r8 = AluRRm(S64, Add) $$r8, $$rdx
    # nextln:           $$rdx = $$rax
    # nextln: 0008:     $$rdx = AluRmI(S64, Add, 1) $$rdx
    # nextln: 0009:     MovMR(S64) $$r8, $$rax
    # nextln: 0010:     AluRRm(S64, Cmp) $$rdx, $$rsi
    # nextln: 0011:     Jumpcc(E, block5, block6)
    # nextln:       block6:
    # nextln:           $$rax = $$rdx
    # nextln: 0012:     Jump(block4)
    # nextln:       block5:
    # nextln: 0013:     Jump(block2)
    # nextln:       block2:
    # nextln: 0014:     Ret

    %entry_ctrl:ctrl, %arr:ptr, %n:i64 = entry
    %zero:i64 = iconst 0
    %zerocmp:i32 = icmp eq %n, %zero
    %iszero:ctrl, %isnonzero:ctrl = brcond %entry_ctrl, %zerocmp
    %loopbody:ctrl, %loopphi:phisel = region %isnonzero, %looplatch
    %i:i64 = phi %loopphi, %zero, %inext
    %three:i64 = iconst 3
    %off:i64 = shl %i, %three
    %ptr:ptr = ptroff %arr, %off
    %poststore:ctrl = store.8 %loopbody, %i, %ptr
    %one:i64 = iconst 1
    %inext:i64 = iadd %i, %one
    %donecmp:i32 = icmp eq %inext, %n
    %loopdone:ctrl, %looplatch:ctrl = brcond %poststore, %donecmp
    %exit:ctrl, %exitphi:phisel = region %iszero, %loopdone
    return %exit
}
