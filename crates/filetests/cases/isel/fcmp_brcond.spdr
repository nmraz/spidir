# run: isel

func @select_oeq:i32(f64, f64, i32, i32) {
    # check: function `select_oeq`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:xmm(reg)[late] = FpuCmp(Eq) %4(tied:0)[early], %5(any)[early]
    # nextln: 0001:      %7:gpr(any)[late] = MovGprmXmm(S64) %6(reg)[early]
    # nextln: 0002:      %3:gpr(any)[late] = AluRmI(S32, And, 1) %7(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp oeq %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_one:i32(f64, f64, i32, i32) {
    # check: function `select_one`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %4(reg)[early], %5(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(Ne) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp one %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_olt:i32(f64, f64, i32, i32) {
    # check: function `select_olt`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %5(reg)[early], %4(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(A) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp olt %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_ole:i32(f64, f64, i32, i32) {
    # check: function `select_ole`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %5(reg)[early], %4(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(Ae) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp ole %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_ueq:i32(f64, f64, i32, i32) {
    # check: function `select_ueq`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %4(reg)[early], %5(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(E) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp ueq %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_une:i32(f64, f64, i32, i32) {
    # check: function `select_une`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:xmm(reg)[late] = FpuCmp(Neq) %4(tied:0)[early], %5(any)[early]
    # nextln: 0001:      %7:gpr(any)[late] = MovGprmXmm(S64) %6(reg)[early]
    # nextln: 0002:      %3:gpr(any)[late] = AluRmI(S32, And, 1) %7(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp une %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_ult:i32(f64, f64, i32, i32) {
    # check: function `select_ult`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %4(reg)[early], %5(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(B) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp ult %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_ule:i32(f64, f64, i32, i32) {
    # check: function `select_ule`:
    # nextln:       block0[%4:xmm($$xmm0), %5:xmm($$xmm1), %2:gpr($$rdi), %1:gpr($$rsi)]:
    # nextln: 0000:      %6:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %4(reg)[early], %5(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(Be) %6(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%2:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%1:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      Ret %0($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp ule %a, %b
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    return %6, %10
}

func @select_olt_cond_reused:i32(f64, f64, i32, i32) {
    # check: function `select_olt_cond_reused`:
    # nextln:       block0[%6:xmm($$xmm0), %7:xmm($$xmm1), %5:gpr($$rdi), %4:gpr($$rsi)]:
    # nextln: 0000:      %8:gpr(any)[late] = MovRmS32(0)
    # nextln: 0001:      FpuRRm(Ucomi) %7(reg)[early], %6(any)[early]
    # nextln: 0002:      %3:gpr(reg)[late] = Setcc(A) %8(tied:0)[early]
    # nextln: 0003:      AluRRm(S32, Test) %3(reg)[early], %3(any)[early]
    # nextln: 0004:      Jumpcc(Ne, block1, block3)
    # nextln:       => block1, block3
    # nextln:       block1:
    # nextln: 0005:      Jump(block2)
    # nextln:       => block2[%5:gpr]
    # nextln:       block3:
    # nextln: 0006:      Jump(block2)
    # nextln:       => block2[%4:gpr]
    # nextln:       block2[%0:gpr]:
    # nextln: 0007:      %2:gpr(any)[late] = AluRmI(S32, Xor, 5) %3(tied:0)[early]
    # nextln: 0008:      %1:gpr(reg)[late] = AluRRm(S32, Add) %0(tied:0)[early], %2(any)[early]
    # nextln: 0009:      Ret %1($$rax)[early]

    %0:ctrl, %a:f64, %b:f64, %2:i32, %3:i32 = entry
    %1:i32 = fcmp olt %a, %b
    %five:i32 = iconst 5
    %thing:i32 = xor %1, %five
    %8:ctrl, %9:ctrl = brcond %0, %1
    %6:ctrl, %7:phisel = region %8, %9
    %10:i32 = phi %7, %2, %3
    %retval:i32 = iadd %10, %thing
    return %6, %retval
}
