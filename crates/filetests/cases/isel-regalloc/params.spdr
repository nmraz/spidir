# run: isel-regalloc

# NOTE: Allocation still isn't ideal here ($rcx and $rdx are clobbered by stack loads) because the
# stack parameters end up with higher spill weights than the register-based ones and thus cannot be
# evicted. This should get better once the allocator is aware of rematerialization.

func @many_params:i64(i64, i64, i64, i64, i64, i64, i64, i64) {
    # check: function `many_params`:
    # nextln: clobbers: rax, rdi, r10
    # nextln: frame: size 0, align 0
    # nextln:       block0:
    # nextln:           $$rax = $$rdi
    # nextln: 0000:     $$rdi = MovRRbp { offset: 24 }
    # nextln: 0001:     $$r10 = MovRRbp { offset: 16 }
    # nextln: 0002:     $$rax = AluRRm(S64, Add) $$rax, $$rsi
    # nextln: 0003:     $$rax = AluRRm(S64, Add) $$rax, $$rdx
    # nextln: 0004:     $$rax = AluRRm(S64, Add) $$rax, $$rcx
    # nextln: 0005:     $$rax = AluRRm(S64, Add) $$rax, $$r8
    # nextln: 0006:     $$rax = AluRRm(S64, Add) $$rax, $$r9
    # nextln: 0007:     $$rax = AluRRm(S64, Add) $$rax, $$r10
    # nextln: 0008:     $$rax = AluRRm(S64, Add) $$rax, $$rdi
    # nextln: 0009:     Ret $$rax

    %c:ctrl, %1:i64, %2:i64, %3:i64, %4:i64, %5:i64, %6:i64, %7:i64, %8:i64 = entry
    %val:i64 = iadd %1, %2
    %val2:i64 = iadd %val, %3
    %val3:i64 = iadd %val2, %4
    %val4:i64 = iadd %val3, %5
    %val5:i64 = iadd %val4, %6
    %val6:i64 = iadd %val5, %7
    %val7:i64 = iadd %val6, %8
    return %c, %val7
}

func @unused_param:i64(ptr, i64, i64) {
    # check: function `unused_param`:
    # nextln: clobbers: rax
    # nextln: frame: size 0, align 0
    # nextln:       block0:
    # nextln:           $$rax = $$rsi
    # nextln: 0000:     $$rax = AluRRm(S64, Add) $$rax, $$rdx
    # nextln: 0001:     Ret $$rax

    %c:ctrl, %p:ptr, %a:i64, %b:i64 = entry
    %val:i64 = iadd %a, %b
    return %c, %val
}
