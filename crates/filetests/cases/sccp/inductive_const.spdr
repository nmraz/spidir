# run: opt[func(sccp)]

extfunc @g()
extfunc @f:i32()

func @inductive_const:i32(i32) {
    # check:   func @inductive_const:i32(i32) {
    # nextln:      $(entry0=$val):ctrl, $(entry1=$val):i32 = entry
    # dag:         $(phi0=$val):i32 = phi $(region0=$val), $entry1, $(call0=$val)
    # dag:         $(brcond0=$val):ctrl, $(brcond1=$val):ctrl = brcond $(region1=$val), $phi0
    # dag:         $(call1=$val):ctrl, $call0:i32 = call @f $brcond0
    # dag:         $region1:ctrl, $region0:phisel = region $entry0, $call1
    # dag:         $(iconst0=$val):i32 = iconst 5
    # dag:         return $brcond1, $iconst0
    # nextln:  }

    %ent:ctrl, %lce:i32 = entry

    %5:i32 = iconst 5

    %lh:ctrl, %lhp:phisel = region %ent, %lbm1
    %lc:i32 = phi %lhp, %lce, %lcn
    %constval:i32 = phi %lhp, %5, %constvaln
    %lb:ctrl, %exit:ctrl = brcond %lh, %lc

    %ccond:i32 = icmp eq %constval, %5
    %lbct:ctrl, %lbcf:ctrl = brcond %lb, %ccond

    %1:i32 = iconst 1
    %3:i32 = iconst 3
    %7:i32 = iconst 7
    %11:i32 = iconst 11
    %25:i32 = iconst 25
    %120:i32 = iconst 120

    %tmp1:i32 = iadd %constval, %7                       # 12
    %tmp2:i32 = isub %tmp1, %5                           # 7
    %tmp3:i32 = and %tmp2, %3                            # 3
    %tmp4:i32 = or %tmp3, %25                            # 27
    %tmp5:i32 = xor %tmp4, %tmp3                         # 24
    %tmp6:i32 = shl %tmp5, %7                            # 3072
    %tmp7:i32 = lshr %tmp6, %1                           # 1536
    %tmp8:i32 = ashr %tmp7, %1                           # 768
    %tmp9:i32 = imul %tmp8, %tmp2                        # 5376
    %lbct2:ctrl, %tmp10:i32 = sdiv %lbct, %tmp9, %3      # 1792
    %lbct3:ctrl, %tmp11:i32 = udiv %lbct2, %tmp10, %7    # 256
    %tmp12:i64 = iext %tmp11                             # 256 + x<<32
    %tmp13:i64 = sfill 32 %tmp12                         # 256
    %tmp14:i32 = itrunc %tmp13                           # 256
    %lbct4:ctrl, %tmp15:i32 = srem %lbct3, %tmp14, %120  # 16
    %lbct5:ctrl, %tmp16:i32 = urem %lbct4, %tmp15, %11   # 5

    %lbcf2:ctrl = call @g %lbcf

    %lbm:ctrl, %lbmp:phisel = region %lbct5, %lbcf2

    %constvaln:i32 = phi %lbmp, %tmp16, %11
    %lbm1:ctrl, %lcn:i32 = call @f %lbm

    return %exit, %constval
}

func @inductive_nonconst:i32(i32) {
    # check:   func @inductive_nonconst:i32(i32) {
    # nextln:      $(entry0=$val):ctrl, $(entry1=$val):i32 = entry
    # dag:         $(iconst0=$val):i32 = iconst 11
    # dag:         $(iconst1=$val):i32 = iconst 120
    # dag:         $(iconst2=$val):i32 = iconst 7
    # dag:         $(iconst3=$val):i32 = iconst 3
    # dag:         $(iconst4=$val):i32 = iconst 5
    # dag:         $(iconst5=$val):i32 = iconst 1
    # dag:         $(iconst6=$val):i32 = iconst 25
    # dag:         $(or0=$val):i32 = or $(and0=$val), $iconst6
    # dag:         $(xor0=$val):i32 = xor $or0, $and0
    # dag:         $(shl0=$val):i32 = shl $xor0, $iconst2
    # dag:         $(lshr0=$val):i32 = lshr $shl0, $iconst5
    # dag:         $(ashr0=$val):i32 = ashr $lshr0, $iconst5
    # dag:         $(imul0=$val):i32 = imul $ashr0, $(isub0=$val)
    # dag:         $(sdiv0=$val):ctrl, $(sdiv1=$val):i32 = sdiv $(brcond0=$val), $imul0, $iconst3
    # dag:         $(udiv0=$val):ctrl, $(udiv1=$val):i32 = udiv $sdiv0, $sdiv1, $iconst2
    # dag:         $(iext0=$val):i64 = iext $udiv1
    # dag:         $(sfill0=$val):i64 = sfill 32 $iext0
    # dag:         $(itrunc0=$val):i32 = itrunc $sfill0
    # dag:         $(srem0=$val):ctrl, $(srem1=$val):i32 = srem $udiv0, $itrunc0, $iconst1
    # dag:         $(urem0=$val):ctrl, $(urem1=$val):i32 = urem $srem0, $srem1, $iconst2
    # dag:         $(phi0=$val):i32 = phi $(region0=$val), $urem1, $iconst0
    # dag:         $(phi1=$val):i32 = phi $(region1=$val), $iconst4, $phi0
    # dag:         $(iadd0=$val):i32 = iadd $phi1, $iconst2
    # dag:         $isub0:i32 = isub $iadd0, $iconst4
    # dag:         $and0:i32 = and $isub0, $iconst3
    # dag:         $(icmp0=$val):i32 = icmp eq $phi1, $iconst4
    # dag:         $brcond0:ctrl, $(brcond1=$val):ctrl = brcond $(brcond2=$val), $icmp0
    # dag:         $(call0=$val):ctrl = call @g $brcond1
    # dag:         $(region2=$val):ctrl, $region0:phisel = region $urem0, $call0
    # dag:         $(call1=$val):ctrl, $(call2=$val):i32 = call @f $region2
    # dag:         $(region3=$val):ctrl, $region1:phisel = region $entry0, $call1
    # dag:         $(phi2=$val):i32 = phi $region1, $entry1, $call2
    # dag:         $brcond2:ctrl, $(brcond3=$val):ctrl = brcond $region3, $phi2
    # dag:         return $brcond3, $phi1
    # nextln:  }

    %ent:ctrl, %lce:i32 = entry

    %5:i32 = iconst 5

    %lh:ctrl, %lhp:phisel = region %ent, %lbm1
    %lc:i32 = phi %lhp, %lce, %lcn
    %constval:i32 = phi %lhp, %5, %constvaln
    %lb:ctrl, %exit:ctrl = brcond %lh, %lc

    %ccond:i32 = icmp eq %constval, %5
    %lbct:ctrl, %lbcf:ctrl = brcond %lb, %ccond

    %1:i32 = iconst 1
    %3:i32 = iconst 3
    %7:i32 = iconst 7
    %11:i32 = iconst 11
    %25:i32 = iconst 25
    %120:i32 = iconst 120

    %tmp1:i32 = iadd %constval, %7                       # 12
    %tmp2:i32 = isub %tmp1, %5                           # 7
    %tmp3:i32 = and %tmp2, %3                            # 3
    %tmp4:i32 = or %tmp3, %25                            # 27
    %tmp5:i32 = xor %tmp4, %tmp3                         # 24
    %tmp6:i32 = shl %tmp5, %7                            # 3072
    %tmp7:i32 = lshr %tmp6, %1                           # 1536
    %tmp8:i32 = ashr %tmp7, %1                           # 768
    %tmp9:i32 = imul %tmp8, %tmp2                        # 5376
    %lbct2:ctrl, %tmp10:i32 = sdiv %lbct, %tmp9, %3      # 1792
    %lbct3:ctrl, %tmp11:i32 = udiv %lbct2, %tmp10, %7    # 256
    %tmp12:i64 = iext %tmp11                             # 256 + x<<32
    %tmp13:i64 = sfill 32 %tmp12                         # 256
    %tmp14:i32 = itrunc %tmp13                           # 256
    %lbct4:ctrl, %tmp15:i32 = srem %lbct3, %tmp14, %120  # 16
    %lbct5:ctrl, %tmp16:i32 = urem %lbct4, %tmp15, %7    # 2

    %lbcf2:ctrl = call @g %lbcf

    %lbm:ctrl, %lbmp:phisel = region %lbct5, %lbcf2

    %constvaln:i32 = phi %lbmp, %tmp16, %11
    %lbm1:ctrl, %lcn:i32 = call @f %lbm

    return %exit, %constval
}
